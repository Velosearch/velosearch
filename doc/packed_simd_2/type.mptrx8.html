<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A vector with 8 `*mut T` lanes"><title>mptrx8 in packed_simd_2 - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="packed_simd_2" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (a266f1199 2023-03-22)" data-search-js="search-a6dd7f063a44c279.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" data-theme-light-css="light-db279b6232be9c13.css" data-theme-dark-css="dark-cf923f49f397b216.css" data-theme-ayu-css="ayu-be46fdc453a55015.css" ></div><script src="../static.files/storage-9184409068f70b79.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-f5a2577c5297a973.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../packed_simd_2/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../packed_simd_2/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">mptrx8</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.add">add</a></li><li><a href="#method.eq">eq</a></li><li><a href="#method.extract">extract</a></li><li><a href="#method.extract_unchecked">extract_unchecked</a></li><li><a href="#method.from_slice_aligned">from_slice_aligned</a></li><li><a href="#method.from_slice_aligned_unchecked">from_slice_aligned_unchecked</a></li><li><a href="#method.from_slice_unaligned">from_slice_unaligned</a></li><li><a href="#method.from_slice_unaligned_unchecked">from_slice_unaligned_unchecked</a></li><li><a href="#method.ge">ge</a></li><li><a href="#method.gt">gt</a></li><li><a href="#method.is_null">is_null</a></li><li><a href="#method.lanes">lanes</a></li><li><a href="#method.le">le</a></li><li><a href="#method.lt">lt</a></li><li><a href="#method.ne">ne</a></li><li><a href="#method.new">new</a></li><li><a href="#method.null">null</a></li><li><a href="#method.offset">offset</a></li><li><a href="#method.offset_from">offset_from</a></li><li><a href="#method.read">read</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.replace_unchecked">replace_unchecked</a></li><li><a href="#method.shuffle1_dyn">shuffle1_dyn</a></li><li><a href="#method.splat">splat</a></li><li><a href="#method.sub">sub</a></li><li><a href="#method.wrapping_add">wrapping_add</a></li><li><a href="#method.wrapping_offset">wrapping_offset</a></li><li><a href="#method.wrapping_offset_from">wrapping_offset_from</a></li><li><a href="#method.wrapping_sub">wrapping_sub</a></li><li><a href="#method.write">write</a></li><li><a href="#method.write_to_slice_aligned">write_to_slice_aligned</a></li><li><a href="#method.write_to_slice_aligned_unchecked">write_to_slice_aligned_unchecked</a></li><li><a href="#method.write_to_slice_unaligned">write_to_slice_unaligned</a></li><li><a href="#method.write_to_slice_unaligned_unchecked">write_to_slice_unaligned_unchecked</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Debug-for-mptrx8%3CT%3E">Debug</a></li><li><a href="#impl-Default-for-mptrx8%3CT%3E">Default</a></li><li><a href="#impl-Eq-for-mptrx8%3CT%3E">Eq</a></li><li><a href="#impl-From%3C%5B*mut+T;+8%5D%3E-for-mptrx8%3CT%3E">From&lt;[*mut T; 8]&gt;</a></li><li><a href="#impl-Hash-for-mptrx8%3CT%3E">Hash</a></li><li><a href="#impl-Into%3C%5B*mut+T;+8%5D%3E-for-mptrx8%3CT%3E">Into&lt;[*mut T; 8]&gt;</a></li><li><a href="#impl-PartialEq%3CSimd%3C%5B*mut+T;+8%5D%3E%3E-for-mptrx8%3CT%3E">PartialEq&lt;Simd&lt;[*mut T; 8]&gt;&gt;</a></li><li><a href="#impl-Simd-for-mptrx8%3CT%3E">Simd</a></li></ul></section><h2><a href="index.html">In packed_simd_2</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Type Definition <a href="index.html">packed_simd_2</a>::<wbr><a class="type" href="#">mptrx8</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub type mptrx8&lt;T&gt; = <a class="struct" href="struct.Simd.html" title="struct packed_simd_2::Simd">Simd</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">8</a>]&gt;;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A vector with 8 <code>*mut T</code> lanes</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-mptrx8%3CT%3E" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-mptrx8%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub const fn <a href="#method.new" class="fn">new</a>(
    x0: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>,
    x1: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>,
    x2: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>,
    x3: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>,
    x4: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>,
    x5: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>,
    x6: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>,
    x7: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>
) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new instance with each vector elements initialized
with the provided values.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lanes" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub const fn <a href="#method.lanes" class="fn">lanes</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of vector lanes.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splat" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub const fn <a href="#method.splat" class="fn">splat</a>(value: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new instance with each element initialized to
<code>value</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.null" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub const fn <a href="#method.null" class="fn">null</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new instance with each element initialized to
<code>null</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_null" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.is_null" class="fn">is_null</a>(self) -&gt; <a class="type" href="type.msizex8.html" title="type packed_simd_2::msizex8">msizex8</a></h4></section></summary><div class="docblock"><p>Returns a mask that selects those lanes that contain <code>null</code>
pointers.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.extract" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.extract" class="fn">extract</a>(self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>Extracts the value at <code>index</code>.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>If <code>index &gt;= Self::lanes()</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.extract_unchecked" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.extract_unchecked" class="fn">extract_unchecked</a>(self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>Extracts the value at <code>index</code>.</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>If <code>index &gt;= Self::lanes()</code> the behavior is undefined.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.replace" class="fn">replace</a>(self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>, new_value: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Returns a new vector where the value at <code>index</code> is replaced by
<code>new_value</code>.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>If <code>index &gt;= Self::lanes()</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace_unchecked" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.replace_unchecked" class="fn">replace_unchecked</a>(self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>, new_value: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Returns a new vector where the value at <code>index</code> is replaced by <code>new_value</code>.</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>If <code>index &gt;= Self::lanes()</code> the behavior is undefined.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-mptrx8%3CT%3E-1" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-mptrx8%3CT%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.eq" class="fn">eq</a>(self, other: Self) -&gt; <a class="type" href="type.msizex8.html" title="type packed_simd_2::msizex8">msizex8</a></h4></section></summary><div class="docblock"><p>Lane-wise equality comparison.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.ne" class="fn">ne</a>(self, other: Self) -&gt; <a class="type" href="type.msizex8.html" title="type packed_simd_2::msizex8">msizex8</a></h4></section></summary><div class="docblock"><p>Lane-wise inequality comparison.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.lt" class="fn">lt</a>(self, other: Self) -&gt; <a class="type" href="type.msizex8.html" title="type packed_simd_2::msizex8">msizex8</a></h4></section></summary><div class="docblock"><p>Lane-wise less-than comparison.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.le" class="fn">le</a>(self, other: Self) -&gt; <a class="type" href="type.msizex8.html" title="type packed_simd_2::msizex8">msizex8</a></h4></section></summary><div class="docblock"><p>Lane-wise less-than-or-equals comparison.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.gt" class="fn">gt</a>(self, other: Self) -&gt; <a class="type" href="type.msizex8.html" title="type packed_simd_2::msizex8">msizex8</a></h4></section></summary><div class="docblock"><p>Lane-wise greater-than comparison.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.ge" class="fn">ge</a>(self, other: Self) -&gt; <a class="type" href="type.msizex8.html" title="type packed_simd_2::msizex8">msizex8</a></h4></section></summary><div class="docblock"><p>Lane-wise greater-than-or-equals comparison.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-mptrx8%3CT%3E-2" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-mptrx8%3CT%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_slice_aligned" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.from_slice_aligned" class="fn">from_slice_aligned</a>(slice: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>]) -&gt; Self</h4></section></summary><div class="docblock"><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not aligned
to an <code>align_of::&lt;Self&gt;()</code> boundary.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_slice_unaligned" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.from_slice_unaligned" class="fn">from_slice_unaligned</a>(slice: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>]) -&gt; Self</h4></section></summary><div class="docblock"><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h5 id="panics-3"><a href="#panics-3">Panics</a></h5>
<p>If <code>slice.len() &lt; Self::lanes()</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_slice_aligned_unchecked" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_slice_aligned_unchecked" class="fn">from_slice_aligned_unchecked</a>(slice: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>]) -&gt; Self</h4></section></summary><div class="docblock"><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h5 id="safety-2"><a href="#safety-2">Safety</a></h5>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not aligned
to an <code>align_of::&lt;Self&gt;()</code> boundary, the behavior is undefined.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_slice_unaligned_unchecked" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_slice_unaligned_unchecked" class="fn">from_slice_unaligned_unchecked</a>(slice: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>]) -&gt; Self</h4></section></summary><div class="docblock"><p>Instantiates a new vector with the values of the <code>slice</code>.</p>
<h5 id="safety-3"><a href="#safety-3">Safety</a></h5>
<p>If <code>slice.len() &lt; Self::lanes()</code> the behavior is undefined.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-mptrx8%3CT%3E-3" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-mptrx8%3CT%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.write_to_slice_aligned" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.write_to_slice_aligned" class="fn">write_to_slice_aligned</a>(self, slice: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>])</h4></section></summary><div class="docblock"><p>Writes the values of the vector to the <code>slice</code>.</p>
<h5 id="panics-4"><a href="#panics-4">Panics</a></h5>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not
aligned to an <code>align_of::&lt;Self&gt;()</code> boundary.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_slice_unaligned" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.write_to_slice_unaligned" class="fn">write_to_slice_unaligned</a>(self, slice: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>])</h4></section></summary><div class="docblock"><p>Writes the values of the vector to the <code>slice</code>.</p>
<h5 id="panics-5"><a href="#panics-5">Panics</a></h5>
<p>If <code>slice.len() &lt; Self::lanes()</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_slice_aligned_unchecked" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.write_to_slice_aligned_unchecked" class="fn">write_to_slice_aligned_unchecked</a>(self, slice: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>])</h4></section></summary><div class="docblock"><p>Writes the values of the vector to the <code>slice</code>.</p>
<h5 id="safety-4"><a href="#safety-4">Safety</a></h5>
<p>If <code>slice.len() &lt; Self::lanes()</code> or <code>&amp;slice[0]</code> is not
aligned to an <code>align_of::&lt;Self&gt;()</code> boundary, the behavior is
undefined.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_slice_unaligned_unchecked" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.write_to_slice_unaligned_unchecked" class="fn">write_to_slice_unaligned_unchecked</a>(self, slice: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>])</h4></section></summary><div class="docblock"><p>Writes the values of the vector to the <code>slice</code>.</p>
<h5 id="safety-5"><a href="#safety-5">Safety</a></h5>
<p>If <code>slice.len() &lt; Self::lanes()</code> the behavior is undefined.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-mptrx8%3CT%3E-4" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-mptrx8%3CT%3E-4" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.offset" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.offset" class="fn">offset</a>(self, count: <a class="type" href="type.isizex8.html" title="type packed_simd_2::isizex8">isizex8</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Calculates the offset from a pointer.</p>
<p><code>count</code> is in units of <code>T</code>; e.g. a count of <code>3</code> represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-6"><a href="#safety-6">Safety</a></h5>
<p>If any of the following conditions are violated, the result is
Undefined Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in
bounds or one byte past the end of an allocated object.</p>
</li>
<li>
<p>The computed offset, in bytes, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on “wrapping around”
the address space. That is, the infinite-precision sum, in bytes
must fit in a <code>usize</code>.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure
allocations never reach a size where an offset is a concern. For
instance, <code>Vec</code> and <code>Box</code> ensure they never allocate more than
<code>isize::MAX</code> bytes, so <code>vec.as_ptr().offset(vec.len() as isize)</code>
is always safe.</p>
<p>Most platforms fundamentally can’t even construct such an
allocation. For instance, no known 64-bit platform can ever
serve a request for 263 bytes due to page-table limitations or
splitting the address space. However, some 32-bit and 16-bit
platforms may successfully serve a request for more than
<code>isize::MAX</code> bytes with things like Physical Address Extension.
As such, memory acquired directly from allocators or memory
mapped files may be too large to handle with this function.</p>
<p>Consider using <code>wrapping_offset</code> instead if these constraints
are difficult to satisfy. The only advantage of this method is
that it enables more aggressive compiler optimizations.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_offset" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.wrapping_offset" class="fn">wrapping_offset</a>(self, count: <a class="type" href="type.isizex8.html" title="type packed_simd_2::isizex8">isizex8</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Calculates the offset from a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of <code>T</code>; e.g. a count of <code>3</code> represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-7"><a href="#safety-7">Safety</a></h5>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires unsafe).</p>
<p>Always use <code>.offset(count)</code> instead when possible, because
offset allows the compiler to optimize better.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset_from" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.offset_from" class="fn">offset_from</a>(self, origin: Self) -&gt; <a class="type" href="type.isizex8.html" title="type packed_simd_2::isizex8">isizex8</a></h4></section></summary><div class="docblock"><p>Calculates the distance between two pointers.</p>
<p>The returned value is in units of <code>T</code>: the distance in bytes is
divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p>This function is the inverse of offset.</p>
<h5 id="safety-8"><a href="#safety-8">Safety</a></h5>
<p>If any of the following conditions are violated, the result is
Undefined Behavior:</p>
<ul>
<li>
<p>Both the starting and other pointer must be either in bounds
or one byte past the end of the same allocated object.</p>
</li>
<li>
<p>The distance between the pointers, in bytes, cannot overflow
an <code>isize</code>.</p>
</li>
<li>
<p>The distance between the pointers, in bytes, must be an exact
multiple of the size of <code>T</code>.</p>
</li>
<li>
<p>The distance being in bounds cannot rely on “wrapping around”
the address space.</p>
</li>
</ul>
<p>The compiler and standard library generally try to ensure
allocations never reach a size where an offset is a concern. For
instance, <code>Vec</code> and <code>Box</code> ensure they never allocate more than
<code>isize::MAX</code> bytes, so <code>ptr_into_vec.offset_from(vec.as_ptr())</code>
is always safe.</p>
<p>Most platforms fundamentally can’t even construct such an
allocation. For instance, no known 64-bit platform can ever
serve a request for 263 bytes due to page-table limitations or
splitting the address space. However, some 32-bit and 16-bit
platforms may successfully serve a request for more than
<code>isize::MAX</code> bytes with things like Physical Address Extension.
As such, memory acquired directly from allocators or memory
mapped files may be too large to handle with this function.</p>
<p>Consider using <code>wrapping_offset_from</code> instead if these constraints
are difficult to satisfy. The only advantage of this method is
that it enables more aggressive compiler optimizations.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_offset_from" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.wrapping_offset_from" class="fn">wrapping_offset_from</a>(self, origin: Self) -&gt; <a class="type" href="type.isizex8.html" title="type packed_simd_2::isizex8">isizex8</a></h4></section></summary><div class="docblock"><p>Calculates the distance between two pointers.</p>
<p>The returned value is in units of <code>T</code>: the distance in bytes is
divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p>If the address different between the two pointers is not a
multiple of <code>mem::size_of::&lt;T&gt;()</code> then the result of the
division is rounded towards zero.</p>
<p>Though this method is safe for any two pointers, note that its
result will be mostly useless if the two pointers aren’t into
the same allocated object, for example if they point to two
different local variables.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.add" class="fn">add</a>(self, count: <a class="type" href="type.usizex8.html" title="type packed_simd_2::usizex8">usizex8</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Calculates the offset from a pointer (convenience for
<code>.offset(count as isize)</code>).</p>
<p><code>count</code> is in units of <code>T</code>; e.g. a count of 3 represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-9"><a href="#safety-9">Safety</a></h5>
<p>If any of the following conditions are violated, the result is
Undefined Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in
bounds or one byte past the end of an allocated object.</p>
</li>
<li>
<p>The computed offset, in bytes, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on “wrapping around”
the address space. That is, the infinite-precision sum must fit
in a <code>usize</code>.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure
allocations never reach a size where an offset is a concern. For
instance, <code>Vec</code> and <code>Box</code> ensure they never allocate more than
<code>isize::MAX</code> bytes, so <code>vec.as_ptr().add(vec.len())</code> is always
safe.</p>
<p>Most platforms fundamentally can’t even construct such an
allocation. For instance, no known 64-bit platform can ever
serve a request for 263 bytes due to page-table limitations or
splitting the address space. However, some 32-bit and 16-bit
platforms may successfully serve a request for more than
<code>isize::MAX</code> bytes with things like Physical Address Extension.
As such, memory acquired directly from allocators or memory
mapped files may be too large to handle with this function.</p>
<p>Consider using <code>wrapping_offset</code> instead if these constraints
are difficult to satisfy. The only advantage of this method is
that it enables more aggressive compiler optimizations.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.sub" class="fn">sub</a>(self, count: <a class="type" href="type.usizex8.html" title="type packed_simd_2::usizex8">usizex8</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Calculates the offset from a pointer (convenience for
<code>.offset((count as isize).wrapping_neg())</code>).</p>
<p><code>count</code> is in units of T; e.g. a <code>count</code> of 3 represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-10"><a href="#safety-10">Safety</a></h5>
<p>If any of the following conditions are violated, the result is
Undefined Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in
bounds or one byte past the end of an allocated object.</p>
</li>
<li>
<p>The computed offset cannot exceed <code>isize::MAX</code> <strong>bytes</strong>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on “wrapping around”
the address space. That is, the infinite-precision sum must fit
in a usize.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure
allocations never reach a size where an offset is a concern. For
instance, <code>Vec</code> and <code>Box</code> ensure they never allocate more than
<code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len()).sub(vec.len())</code> is always safe.</p>
<p>Most platforms fundamentally can’t even construct such an
allocation. For instance, no known 64-bit platform can ever
serve a request for 2<sup>63</sup> bytes due to page-table
limitations or splitting the address space. However, some 32-bit
and 16-bit platforms may successfully serve a request for more
than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or
memory mapped files <em>may</em> be too large to handle with this
function.</p>
<p>Consider using <code>wrapping_offset</code> instead if these constraints
are difficult to satisfy. The only advantage of this method is
that it enables more aggressive compiler optimizations.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_add" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.wrapping_add" class="fn">wrapping_add</a>(self, count: <a class="type" href="type.usizex8.html" title="type packed_simd_2::usizex8">usizex8</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset(count as isize)</code>)</p>
<p><code>count</code> is in units of T; e.g. a <code>count</code> of 3 represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-11"><a href="#safety-11">Safety</a></h5>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>Always use <code>.add(count)</code> instead when possible, because <code>add</code>
allows the compiler to optimize better.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_sub" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.wrapping_sub" class="fn">wrapping_sub</a>(self, count: <a class="type" href="type.usizex8.html" title="type packed_simd_2::usizex8">usizex8</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset((count as isize).wrapping_sub())</code>)</p>
<p><code>count</code> is in units of T; e.g. a <code>count</code> of 3 represents a
pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-12"><a href="#safety-12">Safety</a></h5>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>Always use <code>.sub(count)</code> instead when possible, because <code>sub</code>
allows the compiler to optimize better.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-mptrx8%3CT%3E-5" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-mptrx8%3CT%3E-5" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.shuffle1_dyn" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub fn <a href="#method.shuffle1_dyn" class="fn">shuffle1_dyn</a>&lt;I&gt;(self, indices: I) -&gt; Self<span class="where fmt-newline">where
    Self: Shuffle1Dyn&lt;Indices = I&gt;,</span></h4></section></summary><div class="docblock"><p>Shuffle vector elements according to <code>indices</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-mptrx8%3CT%3E-6" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-mptrx8%3CT%3E-6" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;<span class="where fmt-newline">where
    <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">[T; 8]</a>: <a class="trait" href="trait.SimdArray.html" title="trait packed_simd_2::SimdArray">SimdArray</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.read" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.read" class="fn">read</a>&lt;M&gt;(
    self,
    mask: <a class="struct" href="struct.Simd.html" title="struct packed_simd_2::Simd">Simd</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">[M; 8]</a>&gt;,
    value: <a class="struct" href="struct.Simd.html" title="struct packed_simd_2::Simd">Simd</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">[T; 8]</a>&gt;
) -&gt; <a class="struct" href="struct.Simd.html" title="struct packed_simd_2::Simd">Simd</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">[T; 8]</a>&gt;<span class="where fmt-newline">where
    M: <a class="trait" href="trait.Mask.html" title="trait packed_simd_2::Mask">Mask</a>,
    <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">[M; 8]</a>: <a class="trait" href="trait.SimdArray.html" title="trait packed_simd_2::SimdArray">SimdArray</a>,</span></h4></section></summary><div class="docblock"><p>Reads selected vector elements from memory.</p>
<p>Instantiates a new vector by reading the values from <code>self</code> for
those lanes whose <code>mask</code> is <code>true</code>, and using the elements of
<code>value</code> otherwise.</p>
<p>No memory is accessed for those lanes of <code>self</code> whose <code>mask</code> is
<code>false</code>.</p>
<h5 id="safety-13"><a href="#safety-13">Safety</a></h5>
<p>This method is unsafe because it dereferences raw pointers. The
pointers must be aligned to <code>mem::align_of::&lt;T&gt;()</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-mptrx8%3CT%3E-7" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-mptrx8%3CT%3E-7" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;<span class="where fmt-newline">where
    <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">[T; 8]</a>: <a class="trait" href="trait.SimdArray.html" title="trait packed_simd_2::SimdArray">SimdArray</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.write" class="method"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><h4 class="code-header">pub unsafe fn <a href="#method.write" class="fn">write</a>&lt;M&gt;(self, mask: <a class="struct" href="struct.Simd.html" title="struct packed_simd_2::Simd">Simd</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">[M; 8]</a>&gt;, value: <a class="struct" href="struct.Simd.html" title="struct packed_simd_2::Simd">Simd</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">[T; 8]</a>&gt;)<span class="where fmt-newline">where
    M: <a class="trait" href="trait.Mask.html" title="trait packed_simd_2::Mask">Mask</a>,
    <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">[M; 8]</a>: <a class="trait" href="trait.SimdArray.html" title="trait packed_simd_2::SimdArray">SimdArray</a>,</span></h4></section></summary><div class="docblock"><p>Writes selected vector elements to memory.</p>
<p>Writes the lanes of <code>values</code> for which the mask is <code>true</code> to
their corresponding memory addresses in <code>self</code>.</p>
<p>No memory is accessed for those lanes of <code>self</code> whose <code>mask</code> is
<code>false</code>.</p>
<p>Overlapping memory addresses of <code>self</code> are written to in order
from the lest-significant to the most-significant element.</p>
<h5 id="safety-14"><a href="#safety-14">Safety</a></h5>
<p>This method is unsafe because it dereferences raw pointers. The
pointers must be aligned to <code>mem::align_of::&lt;T&gt;()</code>.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-mptrx8%3CT%3E" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-Debug-for-mptrx8%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-mptrx8%3CT%3E" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-Default-for-mptrx8%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%5B*mut+T;+8%5D%3E-for-mptrx8%3CT%3E" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-From%3C%5B*mut+T;+8%5D%3E-for-mptrx8%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">8</a>]&gt; for <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(array: [<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">8</a>]) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-mptrx8%3CT%3E" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-Hash-for-mptrx8%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;mut H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#239-241">source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.slice.html">[Self]</a>, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;mut H</a>)<span class="where fmt-newline">where
    H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Into%3C%5B*mut+T;+8%5D%3E-for-mptrx8%3CT%3E" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-Into%3C%5B*mut+T;+8%5D%3E-for-mptrx8%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">8</a>]&gt; for <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; [<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">8</a>]</h4></section></summary><div class='docblock'>Converts this type into the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CSimd%3C%5B*mut+T;+8%5D%3E%3E-for-mptrx8%3CT%3E" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-PartialEq%3CSimd%3C%5B*mut+T;+8%5D%3E%3E-for-mptrx8%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Simd.html" title="struct packed_simd_2::Simd">Simd</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">8</a>]&gt;&gt; for <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#method.eq-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;Self</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#method.ne-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;Self</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Simd-for-mptrx8%3CT%3E" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-Simd-for-mptrx8%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.SimdVector.html" title="trait packed_simd_2::SimdVector">Simd</a> for <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Element" class="associatedtype trait-impl"><a href="#associatedtype.Element" class="anchor">§</a><h4 class="code-header">type <a href="trait.SimdVector.html#associatedtype.Element" class="associatedtype">Element</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a></h4></section></summary><div class='docblock'>Element type of the SIMD vector</div></details><details class="toggle" open><summary><section id="associatedconstant.LANES" class="associatedconstant trait-impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#associatedconstant.LANES" class="anchor">§</a><h4 class="code-header">const <a href="trait.SimdVector.html#associatedconstant.LANES" class="constant">LANES</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a> = 8usize</h4></section></summary><div class='docblock'>The number of elements in the SIMD vector.</div></details><details class="toggle" open><summary><section id="associatedtype.LanesType" class="associatedtype trait-impl"><a href="#associatedtype.LanesType" class="anchor">§</a><h4 class="code-header">type <a href="trait.SimdVector.html#associatedtype.LanesType" class="associatedtype">LanesType</a> = [<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u32.html">u32</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.array.html">8</a>]</h4></section></summary><div class='docblock'>The type: <code>[u32; Self::N]</code>.</div></details></div></details><section id="impl-Eq-for-mptrx8%3CT%3E" class="impl"><a class="srclink rightside" href="../src/packed_simd_2/vPtr.rs.html#31-34">source</a><a href="#impl-Eq-for-mptrx8%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="type" href="type.mptrx8.html" title="type packed_simd_2::mptrx8">mptrx8</a>&lt;T&gt;</h3></section></div></section></div></main></body></html>