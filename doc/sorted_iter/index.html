<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides set and relational operations for all iterators in the standard library that are known at compile time to be sorted."><title>sorted_iter - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="sorted_iter" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (a266f1199 2023-03-22)" data-search-js="search-a6dd7f063a44c279.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" data-theme-light-css="light-db279b6232be9c13.css" data-theme-dark-css="dark-cf923f49f397b216.css" data-theme-ayu-css="ayu-be46fdc453a55015.css" ></div><script src="../static.files/storage-9184409068f70b79.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f5a2577c5297a973.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../sorted_iter/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../sorted_iter/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate sorted_iter</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.11</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">sorted_iter</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/sorted_iter/lib.rs.html#1-404">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides set and relational operations for all iterators in the standard library that are known
at compile time to be sorted.</p>
<h2 id="set-operations"><a href="#set-operations">Set operations</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sorted_iter::SortedIterator;

<span class="kw">let </span>primes = <span class="macro">btreeset! </span>{ <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13u64 </span>}.into_iter();
<span class="kw">let </span>fibs = <span class="macro">btreeset! </span>{ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13u64 </span>}.into_iter();
<span class="kw">let </span>fib_primes = primes.intersection(fibs);</code></pre></div>
<p>It is possible to efficiently define set operations on sorted iterators. Sorted iterators are
very common in the standard library. E.g. the elements of a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">BTreeSet</a> or the keys of a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html">BTreeMap</a>
are guaranteed to be sorted according to the element order, as are iterable ranges like <code>0..100</code>.</p>
<p>There are also a number of operations on iterators that preserve the sort order. E.g. if an
iterator is sorted, <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take">take</a>, <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take_while">take_while</a> etc. are going to result in a sorted iterator as well.</p>
<p>Since the complete types of iterators are typically visible in rust, it is possible to encode these
rules at type level. This is what this crate does.</p>
<p>For available set operations, see <a href="trait.SortedIterator.html">SortedIterator</a>.
For sorted iterators in the std lib, see instances for the <a href="sorted_iterator/trait.SortedByItem.html">SortedByItem</a> marker trait.</p>
<h2 id="relational-operations"><a href="#relational-operations">Relational operations</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sorted_iter::SortedPairIterator;

<span class="kw">let </span>cities = <span class="macro">btreemap! </span>{
  <span class="number">1 </span>=&gt; <span class="string">&quot;New York&quot;</span>,
  <span class="number">2 </span>=&gt; <span class="string">&quot;Tokyo&quot;</span>,
  <span class="number">3u8 </span>=&gt; <span class="string">&quot;Berlin&quot;
</span>}.into_iter();
<span class="kw">let </span>countries = <span class="macro">btreemap! </span>{
  <span class="number">1 </span>=&gt; <span class="string">&quot;USA&quot;</span>,
  <span class="number">2 </span>=&gt; <span class="string">&quot;Japan&quot;</span>,
  <span class="number">3u8 </span>=&gt; <span class="string">&quot;Germany&quot;
</span>}.into_iter();
<span class="kw">let </span>cities_and_countries = cities.join(countries);</code></pre></div>
<p>Iterators of pairs that are sorted according to the first element / key are also very common in
the standard library and elsewhere. E.g. the elements of a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html">BTreeMap</a> are guaranteed to be sorted
according to the key order.</p>
<p>The same rules as for sorted iterators apply for preservation of the sort order, except that there
are some additional operations that preserve sort order. Anything that only operates on the value,
like e.g. map or filter_map on the value, is guaranteed to preserve the sort order.</p>
<p>The operations that can be defined on sorted pair operations are the relational operations known
from relational algebra / SQL, namely join, left_join, right_join and outer_join.</p>
<p>For available relational operations, see <a href="trait.SortedPairIterator.html">SortedPairIterator</a>.
For sorted iterators in the std lib, see instances the for <a href="sorted_pair_iterator/trait.SortedByKey.html">SortedByKey</a> marker trait.</p>
<h2 id="transformations-that-retain-order-are-allowed"><a href="#transformations-that-retain-order-are-allowed">Transformations that retain order are allowed</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sorted_iter::<span class="kw-2">*</span>;

<span class="kw">let </span>odd = (<span class="number">1</span>..<span class="number">31</span>).step_by(<span class="number">2</span>);
<span class="kw">let </span>multiples_of_3 = (<span class="number">3</span>..<span class="number">30</span>).step_by(<span class="number">3</span>);
<span class="kw">let </span>either = odd.union(multiples_of_3);</code></pre></div>
<h2 id="transformations-that-can-change-the-order-lose-the-sorted-property"><a href="#transformations-that-can-change-the-order-lose-the-sorted-property">Transformations that can change the order lose the sorted property</a></h2>
<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sorted_iter::<span class="kw-2">*</span>;

<span class="comment">// we have no idea what map does to the order. could be anything!
</span><span class="kw">let </span>a = (<span class="number">1</span>..<span class="number">31</span>).map(|x| -x);
<span class="kw">let </span>b = (<span class="number">3</span>..<span class="number">30</span>).step_by(<span class="number">3</span>);
<span class="kw">let </span>either = a.union(b); <span class="comment">// does not compile!</span></code></pre></div>
<h2 id="assuming-sort-ordering"><a href="#assuming-sort-ordering">Assuming sort ordering</a></h2>
<p>For most std lib iterators, this library already provides instances. But there will occasionally be an iterator
from a third party library where you <em>know</em> that it is properly sorted.</p>
<p>For this case, there is an escape hatch:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// the assume_ extensions have to be implicitly imported
</span><span class="kw">use </span>sorted_iter::<span class="kw-2">*</span>;
<span class="kw">use </span>sorted_iter::assume::<span class="kw-2">*</span>;
<span class="kw">let </span>odd = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7u8</span>].into_iter().assume_sorted_by_item();
<span class="kw">let </span>even = <span class="macro">vec!</span>[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8u8</span>].into_iter().assume_sorted_by_item();
<span class="kw">let </span>all = odd.union(even);

<span class="kw">let </span>cities = <span class="macro">vec!</span>[(<span class="number">1u8</span>, <span class="string">&quot;New York&quot;</span>)].into_iter().assume_sorted_by_key();
<span class="kw">let </span>countries = <span class="macro">vec!</span>[(<span class="number">1u8</span>, <span class="string">&quot;USA&quot;</span>)].into_iter().assume_sorted_by_key();
<span class="kw">let </span>cities_and_countries = cities.join(countries);</code></pre></div>
<h2 id="marking-your-own-iterators"><a href="#marking-your-own-iterators">Marking your own iterators</a></h2>
<p>If you have a library and want to mark some iterators as sorted, this is possible by implementing the
appropriate marker trait, <a href="sorted_iterator/trait.SortedByItem.html">SortedByItem</a> or <a href="sorted_pair_iterator/trait.SortedByKey.html">SortedByKey</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// marker traits are not at top level, since usually you don&#39;t need them
</span><span class="kw">use </span>sorted_iter::sorted_iterator::SortedByItem;
<span class="kw">use </span>sorted_iter::sorted_pair_iterator::SortedByKey;

<span class="kw">pub struct </span>MySortedIter&lt;T&gt; { whatever: T }
<span class="kw">pub struct </span>MySortedPairIter&lt;K, V&gt; { whatever: (K, V) }

<span class="kw">impl</span>&lt;T&gt; SortedByItem <span class="kw">for </span>MySortedIter&lt;T&gt; {}
<span class="kw">impl</span>&lt;K, V&gt; SortedByKey <span class="kw">for </span>MySortedPairIter&lt;K, V&gt; {}</code></pre></div>
<p>By reexporting the extension traits, you get a seamless experience for people using your library.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>sorted_iter;
<span class="kw">pub use </span>sorted_iter::{SortedIterator, SortedPairIterator};</code></pre></div>
<h3 id="tests"><a href="#tests">Tests</a></h3>
<p>Tests are done using the fantastic <a href="https://github.com/BurntSushi/quickcheck">quickcheck</a> crate, by comparing against the operations defined on
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">BTreeSet</a> and <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html">BTreeMap</a>.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.OneOrLess"><code>pub use one_or_less_iterator::<a class="trait" href="one_or_less_iterator/trait.OneOrLess.html" title="trait sorted_iter::one_or_less_iterator::OneOrLess">OneOrLess</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="assume/index.html" title="mod sorted_iter::assume">assume</a></div><div class="desc docblock-short">extension traits for unchecked conversions from iterators to sorted iterators</div></li><li><div class="item-name"><a class="mod" href="one_or_less_iterator/index.html" title="mod sorted_iter::one_or_less_iterator">one_or_less_iterator</a></div><div class="desc docblock-short">Implementation of <a href="one_or_less_iterator/trait.OneOrLess.html" title="trait sorted_iter::one_or_less_iterator::OneOrLess"><code>OneOrLess</code></a> iterators.</div></li><li><div class="item-name"><a class="mod" href="sorted_iterator/index.html" title="mod sorted_iter::sorted_iterator">sorted_iterator</a></div><div class="desc docblock-short">implementation of the sorted_iterator set operations</div></li><li><div class="item-name"><a class="mod" href="sorted_pair_iterator/index.html" title="mod sorted_iter::sorted_pair_iterator">sorted_pair_iterator</a></div><div class="desc docblock-short">implementation of the sorted_pair_iterator relational operations</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.SortedIterator.html" title="trait sorted_iter::SortedIterator">SortedIterator</a></div><div class="desc docblock-short">set operations for iterators where the items are sorted according to the natural order</div></li><li><div class="item-name"><a class="trait" href="trait.SortedPairIterator.html" title="trait sorted_iter::SortedPairIterator">SortedPairIterator</a></div><div class="desc docblock-short">relational operations for iterators of pairs where the items are sorted according to the key</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.multiway_union.html" title="fn sorted_iter::multiway_union">multiway_union</a></div><div class="desc docblock-short">Union of multiple sorted iterators.</div></li></ul></section></div></main></body></html>